""" Vim plugin script
""" Summary: dungeon keeper on Vim
""" Authors: rozeroze <rosettastone1886@gmail.com>
""" Version: 2018-07-24


""" documents
" rule of positions {{{
" buffer-windowå·¦ä¸Šã¯ { 'posx': 1, 'posy': 1 } ã¨ã—ã¦æ‰±ã†
"    +---- example -----
"    |a      c
"    |   b
"    |
" ä¸Šè¨˜ã®å„a,b,cã¯ãã‚Œãã‚Œä»¥ä¸‹ã«ãªã‚‹
"    a: { 'posx': 1, 'posy': 1 }
"    b: { 'posx': 4, 'posy': 2 }
"    c: { 'posx': 8, 'posy': 1 }
" }}}

""" variables
" let s:dungeon {{{
let s:dungeon = {}
let s:dungeon['bufnr'] = 0
let s:dungeon['posx'] = 0
let s:dungeon['posy'] = 0
let s:dungeon['vertical'] = 0
let s:dungeon['horizontal'] = 0
let s:dungeon['path'] = expand('<sfile>:p:h')
" }}}
" let s:master {{{
let s:master = {}
let s:master['list'] = []
function! s:master.add(unit) dict
   call add(self['list'], a:unit)
endfunction
function! s:master.remove(unit) dict
   call s:message.print(printf('call s:master.remove(%s)', a:unit['type']))
   let idx = self.getindex(a:unit)
   call remove(self['list'], idx)
endfunction
function! s:master.exists(x, y) dict
   let _list = deepcopy(self['list'])
   call filter(_list, printf('v:val["posx"] == %s && v:val["posy"] == %s', a:x, a:y))
   if len(_list)
      return _list[0]
   else
      return v:false
   endif
endfunction
function! s:master.getindex(unit) dict
   let idx = index(self['list'], a:unit)
   return idx
endfunction
function! s:master.next() dict
   if len(self['list']) > 1
      let first = self['list'][0]
      call remove(self['list'], 0)
      call self['add'](first)
   endif
endfunction
function! s:master.action() dict
   let unit = self['list'][0]
   if unit['type'] == 'keeper'
      return unit['action']()
   else
      call unit['action']()
      return v:true
   endif
endfunction
" }}}
" let s:message {{{
let s:message = {}
let s:message['list'] = []
function! s:message.print(mes) dict
   "echo a:mes
   call add(self['list'], a:mes)
endfunction
function! s:message.history() dict
   vnew
   setlocal bufhidden=delete buftype=nofile
   call append(line('$'), '====== message history ======')
   for mes in self['list']
      call append(line('$'), mes)
   endfor
endfunction
" }}}
" let s:plain {{{
let s:plain = {}
let s:plain['icon'] = '.'
let s:plain['type'] = 'plain'
function! s:plain.isplain(x, y)
   " xã¨yã‚’ä¸ãˆã€ãã®å ´æ‰€ãŒplainã‹ã©ã†ã‹ã‚’çœŸå½å€¤ã§è¿”ã™
   let cell = getline(a:y)[a:x-1]
   return (cell == '.')
endfunction
function! s:plain.getplain()
   " plainãªå ´æ‰€ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã§é¸æŠã—ã€[posx, posy]ã‚’è¿”ã™
   let lastline = line('$')
   while v:true
      let y = dungeon#random(lastline) + 1
      let line = getline(y)
      let dotcount = count(split(line, '\zs'), '.')
      if dotcount
         let x = match(line, '\.', 0, dungeon#random(dotcount)) + 1
         if s:plain.isplain(x, y)
            return [x, y]
         endif
      endif
   endwhile
endfunction
function! s:plain.getadjacent()
   " plainã«éš£æ¥ã™ã‚‹å ´æ‰€ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã§é¸æŠã—ã€[posx, posy]ã‚’è¿”ã™
endfunction
function! s:plain.replace(x, y, icon)
   let line = getline(a:y)
   let line = line[: a:x-2] . a:icon . line[a:x :]
   call setline(a:y, line)
endfunction
" }}}
" let s:wall {{{
let s:wall = {}
let s:wall['icon'] = ' '
let s:wall['type'] = 'wall'
" }}}
" let s:unit {{{
let s:unit = {}
function! s:unit.move(x, y) dict
   if s:plain.isplain(a:x, a:y)
      call s:message.print(printf('success unit.move(%s)', self['type']))
      call s:plain.replace(self['posx'], self['posy'], s:plain['icon'])
      let self['posx'] = a:x
      let self['posy'] = a:y
      call s:plain.replace(self['posx'], self['posy'], self['icon'])
   endif
endfunction
function! s:unit.move_random() dict
   let rand = dungeon#random(4)
   if rand == 0
      call call(s:unit['move_left'], [], self)
   elseif rand == 1
      call call(s:unit['move_down'], [], self)
   elseif rand == 2
      call call(s:unit['move_up'], [], self)
   elseif rand == 3
      call call(s:unit['move_right'], [], self)
   endif
endfunction
function! s:unit.move_left() dict
   if s:plain.isplain(self['posx'] - 1, self['posy'])
      call s:message.print(printf('success unit.move_left(%s)', self['type']))
      call s:plain.replace(self['posx'], self['posy'], s:plain['icon'])
      let self['posx'] -= 1
      call s:plain.replace(self['posx'], self['posy'], self['icon'])
   endif
endfunction
function! s:unit.move_down() dict
   if s:plain.isplain(self['posx'], self['posy'] + 1)
      call s:message.print(printf('success unit.move_dowm(%s)', self['type']))
      call s:plain.replace(self['posx'], self['posy'], s:plain['icon'])
      let self['posy'] += 1
      call s:plain.replace(self['posx'], self['posy'], self['icon'])
   endif
endfunction
function! s:unit.move_up() dict
   if s:plain.isplain(self['posx'], self['posy'] - 1)
      call s:message.print(printf('success unit.move_up(%s)', self['type']))
      call s:plain.replace(self['posx'], self['posy'], s:plain['icon'])
      let self['posy'] -= 1
      call s:plain.replace(self['posx'], self['posy'], self['icon'])
   endif
endfunction
function! s:unit.move_right() dict
   if s:plain.isplain(self['posx'] + 1, self['posy'])
      call s:message.print(printf('success unit.move_right(%s)', self['type']))
      call s:plain.replace(self['posx'], self['posy'], s:plain['icon'])
      let self['posx'] += 1
      call s:plain.replace(self['posx'], self['posy'], self['icon'])
   endif
endfunction
function! s:unit.damage(...) dict
   call s:message.print(printf('call s:unit.damage(%s)', self['type']))
   if a:0 == 0
      let self['life'] -= (dungeon#random() + 1)
   else
      let self['life'] -= a:1
   endif
   if self['life'] <= 0
      call s:message.print(printf('  unit was died, who type is %s', self['type']))
      call s:master.remove(self)
      call s:plain.replace(self['posx'], self['posy'], s:plain['icon'])
   endif
endfunction
function! s:unit.cure(...) dict
   call s:message.print(printf('call s:unit.cure(%s)', self['type']))
   if a:0 == 0
      let self['life'] += (dungeon#random() + 1)
   else
      let self['life'] += a:1
   endif
endfunction
" }}}
" let s:keeper {{{
let s:keeper = {}
let s:keeper['icon'] = '#'
let s:keeper['type'] = 'keeper'
let s:keeper['posx'] = 0
let s:keeper['posy'] = 0
let s:keeper['life'] = 0
let s:keeper['mana'] = 0
let s:keeper['hate'] = 0
function! s:keeper.action() dict
   let command = nr2char(getchar())
   if command == 'q' || command == ''
      return v:false
   endif
   call self['action_' . command]()
   return v:true
endfunction
function! s:keeper.action_h() dict
   call call(s:unit['move_left'], [], self)
endfunction
function! s:keeper.action_j() dict
   call call(s:unit['move_down'], [], self)
endfunction
function! s:keeper.action_k() dict
   call call(s:unit['move_up'], [], self)
endfunction
function! s:keeper.action_l() dict
   call call(s:unit['move_right'], [], self)
endfunction
function! s:keeper.action_s() dict
   let cross = call(s:action.get_cross, [], self)
   let cross = cross['plain']
   if len(cross) == 0
      call s:message.print('not found plain around keeper')
      return
   endif
   let plain = cross[dungeon#random(len(cross))]
   let name = input('monster type: ', '', 'customlist,dungeon#monsterlist')
   if has_key(s:monsters['dict'], name)
      let monster = deepcopy(s:monsters['dict'][name])
      if self['mana'] >= monster['mana']
         let self['mana'] -= monster['mana']
         let monster['posx'] = plain['posx']
         let monster['posy'] = plain['posy']
         call dungeon#create(monster)
      endif
   endif
endfunction
function! s:keeper['action_w']() dict
   let self['mana'] += 1
endfunction
function! s:keeper.action_d() dict
   " TODO: test
   call dungeon#debug()
   sleep 2000ms
endfunction
function! s:keeper.action_m() dict
   call s:message.history()
   sleep 2000ms
endfunction
" }}}
" let s:gate {{{
let s:gate = {}
let s:gate['icon'] = '%'
let s:gate['type'] = 'gate'
let s:gate['posx'] = 0
let s:gate['posy'] = 0
let s:gate['life'] = 0
let s:gate['mana'] = 0
let s:gate['hate'] = 0
function! s:gate.action() dict
   call s:message.print('gate.action()')
   let self['mana'] += 1
   let cross = call(s:action.get_cross, [], self)
   let cross = cross['plain']
   if len(cross) == 0
      return
   endif
   let plain = cross[dungeon#random(len(cross))]
   if self['mana'] < 8
      return
   endif
   if dungeon#random(3) == 0
      " summon
      let idx = dungeon#random(len(s:braves['list']))
      let name = s:braves['list'][idx]
      let brave = deepcopy(s:braves['dict'][name])
      if self['mana'] >= brave['mana']
         let self['mana'] -= brave['mana']
         let brave['posx'] = plain['posx']
         let brave['posy'] = plain['posy']
         call dungeon#create(brave)
      endif
   endif
endfunction
" }}}

""" action
" let s:action {{{
let s:action = {}
function! s:action.get_cross() dict
   let _cross = {}
   let _cross['list'] = []
   call add( _cross['list'], dungeon#getobj(self['posx']    , self['posy'] - 1) )
   call add( _cross['list'], dungeon#getobj(self['posx']    , self['posy'] + 1) )
   call add( _cross['list'], dungeon#getobj(self['posx'] - 1, self['posy']    ) )
   call add( _cross['list'], dungeon#getobj(self['posx'] + 1, self['posy']    ) )
   let _cross['brave']   = filter(deepcopy(_cross['list']), 'v:val["type"] == "brave"')
   let _cross['gate']    = filter(deepcopy(_cross['list']), 'v:val["type"] == "gate"')
   let _cross['keeper']  = filter(deepcopy(_cross['list']), 'v:val["type"] == "keeper"')
   let _cross['monster'] = filter(deepcopy(_cross['list']), 'v:val["type"] == "monster"')
   let _cross['plain']   = filter(deepcopy(_cross['list']), 'v:val["type"] == "plain"')
   let _cross['wall']    = filter(deepcopy(_cross['list']), 'v:val["type"] == "wall"')
   return _cross
endfunction
function! s:action.attack_brave() dict
   " summary: è¿‘ãã®braveã‚’ç„¡ä½œç‚ºã«æ”»æ’ƒ
   let cross = call(s:action.get_cross, [], self)
   let cross = cross['brave'] + cross['gate']
   if len(cross) != 0
      let target = cross[dungeon#random(len(cross))]
      let index = s:master.getindex(target)
      call call(s:unit['damage'], [], s:master['list'][index])
      return v:true
   endif
   return v:false
endfunction
function! s:action.attack_monster() dict
   " summary: è¿‘ãã®braveã‚’ç„¡ä½œç‚ºã«æ”»æ’ƒ
   let cross = call(s:action.get_cross, [], self)
   let cross = cross['keeper'] + cross['monster']
   if len(cross) != 0
      let target = cross[dungeon#random(len(cross))]
      let index = s:master.getindex(target)
      call call(s:unit['damage'], [], s:master['list'][index])
      return v:true
   endif
   return v:false
endfunction
function! s:action.attack_brave_highhate() dict
   " summary: hateã‚’æœ€ã‚‚ç¨¼ã„ã§ã„ã‚‹braveã‚’æ”»æ’ƒ
   let cross = call(s:action.get_cross, [], self)
   let cross = cross['brave'] + cross['gate']
   if len(cross) != 0
      let _hate = max(map(deepcopy(cross), 'v:val["hate"]' ))
      call filter(cross, printf('v:val["hate"] == %s', _hate))
      let target = cross[dungeon#random(len(cross))]
      let index = s:master.getindex(target)
      call call(s:unit['damage'], [], s:master['list'][index])
      return v:true
   endif
   return v:false
endfunction
function! s:action.attack_monster_highhate() dict
   " summary: hateã‚’æœ€ã‚‚ç¨¼ã„ã§ã„ã‚‹monsterã‚’æ”»æ’ƒ
   let cross = call(s:action.get_cross, [], self)
   let cross = cross['keeper'] + cross['monster']
   if len(cross) != 0
      let _hate = max(map(deepcopy(cross), 'v:val["hate"]' ))
      call filter(cross, printf('v:val["hate"] == %s', _hate))
      let target = cross[dungeon#random(len(cross))]
      let index = s:master.getindex(target)
      call call(s:unit['damage'], [], s:master['list'][index])
      return v:true
   endif
   return v:false
endfunction
function! s:action.move_access(unit) dict
   let actions = []
   let x = a:unit['posx'] - self['posx']
   let y = a:unit['posy'] - self['posy']
   if x > 0
      call add(actions, 'move_right')
   elseif x < 0
      call add(actions, 'move_left')
   endif
   if y > 0
      call add(actions, 'move_down')
   elseif y < 0
      call add(actions, 'move_up')
   endif
   let action = actions[dungeon#random(len(actions))]
   call call(s:unit[action], [], self)
endfunction
function! s:action.move_enemy() dict
   let enemy = deepcopy(s:master['list'])
   if self['type'] == 'brave'
      call filter(enemy, 'v:val["type"] == "keeper" || v:val["type"] == "monster"')
   else
      call filter(enemy, 'v:val["type"] == "brave" || v:val["type"] == "gate"')
   endif
   let _distance = min(map(deepcopy(enemy), printf('abs(v:val["posx"] - %s) + abs(v:val["posy"] - %s)', self['posx'], self['posy'])))
   if _distance < 2
      return
   endif
   call filter(enemy, printf('abs(v:val["posx"] - %s) + abs(v:val["posy"] - %s) == %s', self['posx'], self['posy'], _distance))
   let enemy = enemy[dungeon#random(len(enemy))]
   call call(s:action.move_access, [enemy], self)
endfunction
function! s:action.move_friend() dict
   let friend = deepcopy(s:master['list'])
   if self['type'] == 'brave'
      call filter(friend, 'v:val["type"] == "brave" || v:val["type"] == "gate"')
   else
      call filter(friend, 'v:val["type"] == "keeper" || v:val["type"] == "monster"')
   endif
   let _distance = min(map(deepcopy(friend), printf('abs(v:val["posx"] - %s) + abs(v:val["posy"] - %s)', self['posx'], self['posy'])))
   if _distance < 2
      return
   endif
   call filter(friend, printf('abs(v:val["posx"] - %s) + abs(v:val["posy"] - %s) == %s', self['posx'], self['posy'], _distance))
   let friend = friend[dungeon#random(len(friend))]
   call call(s:action.move_access, [friend], self)
endfunction
function! s:action.confusion() dict
   " summary: å››æ–¹ã‚’randomã«é¸ã³ã€plainãªã‚‰ç§»å‹•ã€å£ã¯ä½•ã‚‚ã›ãšã€ä»–ãªã‚‰æ”»æ’ƒ
   let cross = call(s:action.get_cross, [], self)
   let cross = cross['list']
   let target = cross[dungeon#random(len(cross))]
   if target['type'] == 'plain'
      " ç§»å‹•
      call call(s:unit['move'], [target['posx'], target['posy']], self)
   elseif target['type'] == 'wall'
      " å£ãªã‚‰ä½•ã‚‚ã—ãªã„
   else
      " æ®´ã‚‹
      let index = s:master.getindex(target)
      call call(s:unit['damage'], [], s:master['list'][index])
   endif
endfunction
function! s:action.berserker() dict
   " summary: å‘¨ã‚Šã«ä½•ã‚‚ãªã‘ã‚Œã°ç§»å‹•ã€
   "          ã‚ã‚Œã°ã€ã¨ã«ã‹ãæ®´ã‚‹
   let cross = call(s:action.get_cross, [], self)
   if len(cross['plain']) == 4
      call call(s:unit['move_random'], [], self)
   else
      let cross = cross['list']
      let target = cross[dungeon#random(len(cross))]
      if target['type'] == 'wall'
         call call(s:unit['damage'], [], self)
      else
         let index = s:master.getindex(target)
         call call(s:unit['damage'], [], s:master['list'][index])
      endif
   endif
endfunction
" }}}
" function s:action.{monster}() {{{
function! s:action.bat() dict
   " priority: attack
   " move: random
   " attack: è¿‘ãã®æ•µã‚’ç„¡ä½œç‚ºã«æ”»æ’ƒ
   " skill: å¸è¡€(cure) ã¾ã‚Œã«ç™ºå‹•
   call s:message.print('bat turn')
   if call(s:action.attack_brave, [], self)
      if dungeon#random(7) == 0 && self['life'] < 4
         call call(s:unit['cure'], [], self)
      endif
   else
      call call(s:unit['move_random'], [], self)
   endif
endfunction
function! s:action.slime() dict
   " priority: attack
   " move: æ™‚ã€…randomã«å‹•ã
   " attack: è¿‘ãã®æ•µã‚’ç„¡ä½œç‚ºã«æ”»æ’ƒ
   " skill: åˆ†è£‚
   call s:message.print('slime turn')
   if call(s:action.attack_brave, [], self)
      " no action
   else
      if dungeon#random(3) == 0
         call call(s:unit['move_random'], [], self)
      elseif dungeon#random(5) == 0
         let self['mana'] += dungeon#random()
      elseif dungeon#random(7) == 0
         " skill åˆ†è£‚
      endif
   endif
endfunction
function! s:action.goblin() dict
   " priority: ä»²é–“ãŒè¿‘ãã«ã„ã‚Œã°æ”»æ’ƒã€ã„ãªã‘ã‚Œã°ä»²é–“ã®è¿‘ãã«ç§»å‹•
   " move: ä»²é–“ã®è¿‘ãã«
   " attack: hateãŒé«˜ã„æ•µ
   " skill: none
   call s:message.print('goblin turn')
   let cross = call(s:action.get_cross, [], self)
   let braves = cross['brave'] + cross['gate']
   let keepers = cross['keeper'] + cross['monster']
   if len(keepers) > 0
      " è¿‘ãã«ä»²é–“ãŒã„ã‚‹
      if call(s:action.attack_brave, [], self)
      endif
   else
      " è¿‘ãã«ä»²é–“ãŒã„ãªã„
   endif
endfunction
function! s:action.gengar() dict
   " priority: none
   " move: åŸºæœ¬å‹•ã‹ãªã„ã€è¿‘ãã«èª°ã‹ãŒã„ã‚‹ã¨ã€ã„ãªã„æ–¹å‘ã«ç§»å‹•
   " attack: near-enemy
   " skill: è‡ªèº«ã®hateå€¤ãŒä¸‹ãŒã‚‹
   call s:message.print('gengar turn')
endfunction
function! s:action.skeleton() dict
   " priority: attack
   " move: near-enemy
   " attack: near-enemy
   " skill: æ•µã‚’å€’ã—ãŸã¨ãã€è‡ªèº«ã®manaã‚’æ¶ˆè²»ã—æ­»ä½“ã‚’skeletonã«ã™ã‚‹
   call s:message.print('skeleton turn')
endfunction
function! s:action.element() dict
   " priority: escape, cure me, cure friend
   " move: åŸºæœ¬å‹•ã‹ãªã„ã€è¿‘ãã«æ•µãŒã„ã‚‹ã¨é€ƒã’ã‚‹
   " attack: æ”»æ’ƒã—ãªã„ã€è‡ªèº«ã‹ä»²é–“ã‚’cure
   " skill: å›å¾©(mana1ã‚’æ¶ˆè²») ã¾ã‚Œã«manaã‚’å›å¾©
   call s:message.print('element turn')
endfunction
function! s:action.armor() dict
   " priority: attack
   " move: near-enemy
   " attack: high hate
   " skill: none
   call s:message.print('armor turn')
endfunction
function! s:action.harpy() dict
   " priority: attack
   " move: è¿‘ãã®ä»²é–“ã®ã¨ã“ã‚ã«ç§»å‹•
   " attack: high hate
   " skill: é­…äº†
   call s:message.print('harpy turn')
endfunction
function! s:action.fiary() dict
   " priority: escape
   " move: æ™‚ã€…randomã«å‹•ã
   " attack: æ”»æ’ƒã™ã‚‹ã‹ã€æŠ€èƒ½ã‚’ã¤ã‹ã†
   " skill: å¯¾è±¡ã‚’çŠ¶æ…‹ç•°å¸¸(æ··ä¹±)ã«ã™ã‚‹ changeling
   call s:message.print('fiary turn')
endfunction
function! s:action.witch() dict
   " priority: manaã®çŠ¶æ…‹ã«ã‚ˆã‚‹
   " move: è¿‘ãã«æ•µãŒã„ã‚‹(manaæœ‰æ”»æ’ƒã€manaç„¡é€ƒã’ã‚‹)
   "       æ•µãŒã„ãªã„(manaæœ‰randomç§»å‹•ã€manaç„¡ç§»å‹•ã›ãšmanaå›å¾©)
   " attack: manaã‚’æ¶ˆè²»ã—æŠ€èƒ½ã‚’ä½¿ã†
   " skill: å¯¾è±¡ã‚’çŠ¶æ…‹ç•°å¸¸(ç‹‚åŒ–)ã«ã™ã‚‹
   call s:message.print('witch turn')
endfunction
" }}}
" function s:action.{brave}() {{{
function! s:action.fighter() dict
   " priority: attack
   " move: near-enemy
   " attack: è¿‘ãã®æ•µã‚’ç„¡ä½œç‚ºã«æ”»æ’ƒ
   " skill: none
   call s:message.print('fighter turn')
   if !call(s:action.attack_monster, [], self)
      call call(s:action.move_enemy, [], self)
   endif
endfunction
function! s:action.sword() dict
   call s:message.print('sword turn')
   if !call(s:action.attack_monster, [], self)
      call call(s:action.move_enemy, [], self)
   endif
endfunction
function! s:action.bishop() dict
   call s:message.print('bishop turn')
   if !call(s:action.attack_monster, [], self)
      call call(s:action.move_enemy, [], self)
   endif
endfunction
function! s:action.kid() dict
   call s:message.print('kid turn')
   if !call(s:action.attack_monster, [], self)
      call call(s:action.move_enemy, [], self)
   endif
endfunction
function! s:action.lancer() dict
   call s:message.print('lancer turn')
   if !call(s:action.attack_monster, [], self)
      call call(s:action.move_enemy, [], self)
   endif
endfunction
function! s:action.tamer() dict
   call s:message.print('tamer turn')
   if !call(s:action.attack_monster, [], self)
      call call(s:action.move_enemy, [], self)
   endif
endfunction
function! s:action.rook() dict
   call s:message.print('rook turn')
   if !call(s:action.attack_monster, [], self)
      call call(s:action.move_enemy, [], self)
   endif
endfunction
function! s:action.assassin() dict
   call s:message.print('assassin turn')
   if !call(s:action.attack_monster, [], self)
      call call(s:action.move_enemy, [], self)
   endif
endfunction
function! s:action.wizard() dict
   call s:message.print('wizard turn')
   if !call(s:action.attack_monster, [], self)
      call call(s:action.move_enemy, [], self)
   endif
endfunction
function! s:action.magician() dict
   call s:message.print('magician turn')
   if !call(s:action.attack_monster, [], self)
      call call(s:action.move_enemy, [], self)
   endif
endfunction
function! s:action.criminal() dict
   call s:message.print('criminal turn')
   if !call(s:action.attack_monster, [], self)
      call call(s:action.move_enemy, [], self)
   endif
endfunction
" }}}

""" monsters & braves
" let s:monsters {{{
let s:monsters = {}
let s:monsters['list'] = [ 'bat', 'slime', 'goblin', 'gengar', 'skeleton', 'element', 'armor', 'harpy', 'fiary', 'witch' ]
let s:monsters['dict'] = {
         \ 'bat':      { 'icon': '^', 'type': 'monster', 'life': 2, 'mana': 2, 'hate': 1, 'action': s:action.bat },
         \ 'slime':    { 'icon': '3', 'type': 'monster', 'life': 2, 'mana': 3, 'hate': 0, 'action': s:action.slime },
         \ 'goblin':   { 'icon': '@', 'type': 'monster', 'life': 3, 'mana': 3, 'hate': 2, 'action': s:action.goblin },
         \ 'gengar':   { 'icon': '&', 'type': 'monster', 'life': 4, 'mana': 7, 'hate': 0, 'action': s:action.gengar },
         \ 'skeleton': { 'icon': '!', 'type': 'monster', 'life': 3, 'mana': 3, 'hate': 0, 'action': s:action.skeleton },
         \ 'element':  { 'icon': '8', 'type': 'monster', 'life': 2, 'mana': 5, 'hate': 0, 'action': s:action.element },
         \ 'armor':    { 'icon': '=', 'type': 'monster', 'life': 8, 'mana': 7, 'hate': 0, 'action': s:action.armor },
         \ 'harpy':    { 'icon': '~', 'type': 'monster', 'life': 4, 'mana': 6, 'hate': 0, 'action': s:action.harpy },
         \ 'fiary':    { 'icon': '*', 'type': 'monster', 'life': 3, 'mana': 6, 'hate': 0, 'action': s:action.fiary },
         \ 'witch':    { 'icon': '$', 'type': 'monster', 'life': 4, 'mana': 7, 'hate': 0, 'action': s:action.witch }
         \ }
" }}}
" let s:braves {{{
let s:braves = {}
let s:braves['list'] = [ 'fighter', 'sword', 'bishop', 'kid', 'lancer', 'tamer', 'rook', 'assassin', 'wizard', 'magician', 'criminal' ]
let s:braves['dict'] = {
         \ 'fighter':  { 'icon': 'F', 'type': 'brave', 'life': 4, 'mana': 5, 'hate': 0, 'action': s:action.fighter },
         \ 'sword':    { 'icon': 'S', 'type': 'brave', 'life': 5, 'mana': 5, 'hate': 0, 'action': s:action.sword },
         \ 'bishop':   { 'icon': 'B', 'type': 'brave', 'life': 3, 'mana': 5, 'hate': 0, 'action': s:action.bishop },
         \ 'kid':      { 'icon': 'K', 'type': 'brave', 'life': 1, 'mana': 4, 'hate': 0, 'action': s:action.kid },
         \ 'lancer':   { 'icon': 'L', 'type': 'brave', 'life': 6, 'mana': 8, 'hate': 0, 'action': s:action.lancer },
         \ 'tamer':    { 'icon': 'T', 'type': 'brave', 'life': 3, 'mana': 6, 'hate': 1, 'action': s:action.tamer },
         \ 'rook':     { 'icon': 'R', 'type': 'brave', 'life': 3, 'mana': 4, 'hate': 0, 'action': s:action.rook },
         \ 'assassin': { 'icon': 'A', 'type': 'brave', 'life': 3, 'mana': 7, 'hate': 2, 'action': s:action.assassin },
         \ 'wizard':   { 'icon': 'W', 'type': 'brave', 'life': 3, 'mana': 9, 'hate': 0, 'action': s:action.wizard },
         \ 'magician': { 'icon': 'M', 'type': 'brave', 'life': 3, 'mana': 8, 'hate': 1, 'action': s:action.magician },
         \ 'criminal': { 'icon': 'C', 'type': 'brave', 'life': 5, 'mana': 5, 'hate': 6, 'action': s:action.criminal }
         \}
" }}}
" function dungeon#monsterlist(...) {{{
function! dungeon#monsterlist(...)
   return s:monsters['list']
endfunction
" }}}
" function dungeon#bravelist(...) {{{
function! dungeon#bravelist(...)
   return s:braves['list']
endfunction
" }}}

""" functions common
" function dungeon#clear() {{{
function! dungeon#clear()
   if s:dungeon['bufnr'] != 0
      if bufexists(s:dungeon['bufnr'])
         call execute(printf('bdelete %s', s:dungeon['bufnr']), 'silent')
      endif
   endif
   let s:dungeon['bufnr'] = 0
   let s:dungeon['posx'] = 0
   let s:dungeon['posy'] = 0
   let s:dungeon['vertical'] = 0
   let s:dungeon['horizontal'] = 0
   let s:master['list'] = []
endfunction
" }}}
" function dungeon#argument(arg) {{{
function! dungeon#checkarg(arg)
   let list = ['tutor']
   for t in list
      if a:arg == t
         return a:arg
      endif
   endfor
   return ''
endfunction
" }}}
" function dungeon#create(obj) {{{
function! dungeon#create(obj)
   call s:message.print(printf('call dungeon#create(%s)', a:obj['type']))
   call s:plain.replace(a:obj['posx'], a:obj['posy'], a:obj['icon'])
   call s:master.add(a:obj)
endfunction
" }}}
" function dungeon#random(...) {{{
function! dungeon#random(...)
   if a:0 == 0
      let l:rand = 2
   else
      let l:rand = a:1
   endif
   let log = -1 * (float2nr(log10(l:rand)) + 1)
   let ret = reltimestr(reltime())[log:]
   return ret % l:rand
endfunction
" }}}
" function dungeon#getobj(x, y) {{{
function! dungeon#getobj(x, y)
   let obj = s:master.exists(a:x, a:y)
   if type(obj) == v:t_dict
      return obj
   endif
   let obj = {}
   let obj['posx'] = a:x
   let obj['posy'] = a:y
   if s:plain.isplain(a:x, a:y)
      let obj['icon'] = '.'
      let obj['type'] = 'plain'
   else
      let obj['icon'] = ' '
      let obj['type'] = 'wall'
   endif
   return obj
endfunction
" }}}
" function dungeon#debug() {{{
function! dungeon#debug()
   vnew
   setlocal bufhidden=delete buftype=nofile
   call append(line('$'), '======= dungeon =======')
   for key in keys(s:dungeon)
      call append(line('$'), printf('dungeon.%s: %s', key, s:dungeon[key]))
   endfor
   call append(line('$'), '======= master-list =======')
   for unit in s:master['list']
      call append(line('$'), printf('%s:', unit['type']))
      for key in keys(unit)
         call append(line('$'), printf('  %s: %s', key, unit[key]))
      endfor
   endfor
endfunction
" }}}

""" functions initation
" function dungeon#open() {{{
function! dungeon#open()
   if s:dungeon['bufnr'] == 0
      tabnew [dungeon]
      setlocal filetype=dungeon
      setlocal nobackup noswapfile noundofile
      setlocal bufhidden=delete buftype=nofile
      setlocal nonumber norelativenumber
      setlocal nolist nospell nowrap
      setlocal nocursorline nocursorcolumn
      setlocal guioptions=
      autocmd! QuitPre <buffer> :call dungeon#clear()
      return
   endif
   if !bufexists(s:dungeon['bufnr'])
      echo 'error: buffer not found. -dungeon.vim'
      call dungeon#clear()
      return
   endif
   " MEMO: åˆ†å‰²ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«ã¯å¯¾å¿œã—ã¦ãªã„
   let l:loop = v:true
   while l:loop
      let l:bufnr = bufnr('%')
      if s:dungeon['bufnr'] == l:bufnr
         let l:loop = v:false
      else
         normal! gt
      endif
   endwhile
endfunction
" }}}
" function dungeon#makefield() {{{
function! dungeon#makefield()
   let s:dungeon['posx'] = &columns / (2 + dungeon#random(6))
   let s:dungeon['posy'] = &lines   / (2 + dungeon#random(6))
   let s:dungeon['vertical']   = 5 + dungeon#random(3)
   let s:dungeon['horizontal'] = 5 + dungeon#random(3)
   silent normal! ggdG
   call append(line('$'), repeat([''], s:dungeon['posy'] - 1))
   call append(line('$'), repeat(
            \ [repeat(' ', s:dungeon['posx'] - 1) . repeat('.', s:dungeon['horizontal'])],
            \ s:dungeon['vertical'] ))
   silent normal! ggdd
endfunction
" }}}
" function dungeon#keeperstand() {{{
function! dungeon#keeperstand()
   let keeper = deepcopy(s:keeper)
   let [keeper['posx'], keeper['posy']] = s:plain.getplain()
   let keeper['life'] = 10
   let keeper['mana'] = 10
   call dungeon#create(keeper)
endfunction
" }}}
" function dungeon#makegate() {{{
function! dungeon#makegate()
   let gate = deepcopy(s:gate)
   let [gate['posx'], gate['posy']] = s:plain.getplain()
   let gate['life'] = 25
   let gate['mana'] = 10
   call dungeon#create(gate)
endfunction
" }}}
" function dungeon#readfield(arg) {{{
function! dungeon#readfield(arg)
   silent normal! ggdG
   execute 'r ' . s:dungeon['path'] . '\' . a:arg . '.dung'
endfunction
" }}}
" function dungeon#setunits() {{{
function! dungeon#setunits()
   " TODO: ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’ä½œã‚‹ã®ã§ã¯ãªãã€
   "       ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ãƒ†ã‚­ã‚¹ãƒˆã‚’ç”Ÿæˆã™ã‚‹ã‚ˆã†å¤‰æ›´
   let lastline = line('$')
   let linenr = 1
   while linenr <= lastline
      let line = getline(linenr)
      let colnr = 0
      let lastcol = len(line) - 1
      while colnr <= lastcol
         let c = line[colnr]
         if c == '#'
            let keeper = deepcopy(s:keeper)
            let keeper['posx'] = colnr + 1
            let keeper['posy'] = linenr
            let keeper['life'] = 10
            let keeper['mana'] = 10
            call dungeon#create(keeper)
         endif
         let colnr += 1
      endwhile
      let linenr += 1
   endwhile
endfunction
" }}}


function! dungeon#make(...)
   let arg = (a:0 ? a:1 : '')
   if arg != ''
      call dungeon#clear()
      let arg = dungeon#checkarg(arg)
   endif
   call dungeon#open()
   if s:dungeon['bufnr'] == 0
      let s:dungeon['bufnr'] = bufnr('%')
      if arg == ''
         call dungeon#makefield()
         call dungeon#keeperstand()
         call dungeon#makegate()
      else
         call dungeon#readfield(arg)
         call dungeon#setunits()
      endif
   endif
   redraw
   let loop = v:true
   while loop
      let loop = s:master['action']()
      call s:master['next']()
      redraw
      sleep 300ms
   endwhile
   quit
endfunction


" vim: set ts=3 sts=3 sw=3 et :

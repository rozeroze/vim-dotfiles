""" Vim plugin script
""" Summary: dungeon keeper on Vim
""" Authors: rozeroze <rosettastone1886@gmail.com>
""" Version: 2018-07-24


""" documents
" rule of positions {{{
" buffer-windowÂ∑¶‰∏ä„ÅØ { 'posx': 1, 'posy': 1 } „Å®„Åó„Å¶Êâ±„ÅÜ
"    +---- example -----
"    |a      c
"    |   b
"    |
" ‰∏äË®ò„ÅÆÂêÑa,b,c„ÅØ„Åù„Çå„Åû„Çå‰ª•‰∏ã„Å´„Å™„Çã
"    a: { 'posx': 1, 'posy': 1 }
"    b: { 'posx': 4, 'posy': 2 }
"    c: { 'posx': 8, 'posy': 1 }
" }}}

""" variables
" let s:dungeon {{{
let s:dungeon = {}
let s:dungeon['bufnr'] = 0
let s:dungeon['posx'] = 0
let s:dungeon['posy'] = 0
let s:dungeon['vertical'] = 0
let s:dungeon['horizontal'] = 0
" }}}
" let s:master {{{
let s:master = {}
let s:master['list'] = []
function! s:master.add(unit) dict
   call add(self['list'], a:unit)
endfunction
function! s:master.remove(unit) dict
   call s:message.print(printf('call s:master.remove(%s)', a:unit['type']))
   let idx = self.getindex(a:unit)
   call remove(self['list'], idx)
endfunction
function! s:master.exists(x, y) dict
   let _list = deepcopy(self['list'])
   call filter(_list, printf('v:val["posx"] == %s && v:val["posy"] == %s', a:x, a:y))
   if len(_list)
      return _list[0]
   else
      return v:false
   endif
endfunction
function! s:master.getindex(unit) dict
   let idx = index(self['list'], a:unit)
   return idx
endfunction
function! s:master.next() dict
   if len(self['list']) > 1
      let first = self['list'][0]
      call remove(self['list'], 0)
      call self['add'](first)
   endif
endfunction
function! s:master.action() dict
   let unit = self['list'][0]
   if unit['type'] == 'keeper'
      return unit['action']()
   else
      call unit['action']()
      return v:true
   endif
endfunction
" }}}
" let s:message {{{
let s:message = {}
let s:message['list'] = []
function! s:message.print(mes) dict
   "echo a:mes
   call add(self['list'], a:mes)
endfunction
function! s:message.history() dict
   vnew
   setlocal bufhidden=delete buftype=nofile
   call append(line('$'), '====== message history ======')
   for mes in self['list']
      call append(line('$'), mes)
   endfor
endfunction
" }}}
" let s:plain {{{
let s:plain = {}
let s:plain['icon'] = '.'
let s:plain['type'] = 'plain'
function! s:plain.isplain(x, y)
   " x„Å®y„Çí‰∏é„Åà„ÄÅ„Åù„ÅÆÂ†¥ÊâÄ„Ååplain„Åã„Å©„ÅÜ„Åã„ÇíÁúüÂÅΩÂÄ§„ÅßËøî„Åô
   let cell = getline(a:y)[a:x-1]
   return (cell == '.')
endfunction
function! s:plain.getplain()
   " plain„Å™Â†¥ÊâÄ„Çí„É©„É≥„ÉÄ„É†„ÅßÈÅ∏Êäû„Åó„ÄÅ[posx, posy]„ÇíËøî„Åô
   let lastline = line('$')
   while v:true
      let y = dungeon#random(lastline) + 1
      let line = getline(y)
      let dotcount = count(split(line, '\zs'), '.')
      if dotcount
         let x = match(line, '\.', 0, dungeon#random(dotcount)) + 1
         if s:plain.isplain(x, y)
            return [x, y]
         endif
      endif
   endwhile
endfunction
function! s:plain.getadjacent()
   " plain„Å´Èö£Êé•„Åô„ÇãÂ†¥ÊâÄ„Çí„É©„É≥„ÉÄ„É†„ÅßÈÅ∏Êäû„Åó„ÄÅ[posx, posy]„ÇíËøî„Åô
endfunction
function! s:plain.replace(x, y, icon)
   let line = getline(a:y)
   let line = line[: a:x-2] . a:icon . line[a:x :]
   call setline(a:y, line)
endfunction
" }}}
" let s:wall {{{
let s:wall = {}
let s:wall['icon'] = ' '
let s:wall['type'] = 'wall'
" }}}
" let s:unit {{{
let s:unit = {}
function! s:unit.move(x, y) dict
   if s:plain.isplain(a:x, a:y)
      call s:message.print(printf('success unit.move(%s)', self['type']))
      call s:plain.replace(self['posx'], self['posy'], s:plain['icon'])
      let self['posx'] = a:x
      let self['posy'] = a:y
      call s:plain.replace(self['posx'], self['posy'], self['icon'])
   endif
endfunction
function! s:unit.move_random() dict
   let rand = dungeon#random(4)
   if rand == 0
      call call(s:unit['move_left'], [], self)
   elseif rand == 1
      call call(s:unit['move_down'], [], self)
   elseif rand == 2
      call call(s:unit['move_up'], [], self)
   elseif rand == 3
      call call(s:unit['move_right'], [], self)
   endif
endfunction
function! s:unit.move_left() dict
   if s:plain.isplain(self['posx'] - 1, self['posy'])
      call s:message.print(printf('success unit.move_left(%s)', self['type']))
      call s:plain.replace(self['posx'], self['posy'], s:plain['icon'])
      let self['posx'] -= 1
      call s:plain.replace(self['posx'], self['posy'], self['icon'])
   endif
endfunction
function! s:unit.move_down() dict
   if s:plain.isplain(self['posx'], self['posy'] + 1)
      call s:message.print(printf('success unit.move_dowm(%s)', self['type']))
      call s:plain.replace(self['posx'], self['posy'], s:plain['icon'])
      let self['posy'] += 1
      call s:plain.replace(self['posx'], self['posy'], self['icon'])
   endif
endfunction
function! s:unit.move_up() dict
   if s:plain.isplain(self['posx'], self['posy'] - 1)
      call s:message.print(printf('success unit.move_up(%s)', self['type']))
      call s:plain.replace(self['posx'], self['posy'], s:plain['icon'])
      let self['posy'] -= 1
      call s:plain.replace(self['posx'], self['posy'], self['icon'])
   endif
endfunction
function! s:unit.move_right() dict
   if s:plain.isplain(self['posx'] + 1, self['posy'])
      call s:message.print(printf('success unit.move_right(%s)', self['type']))
      call s:plain.replace(self['posx'], self['posy'], s:plain['icon'])
      let self['posx'] += 1
      call s:plain.replace(self['posx'], self['posy'], self['icon'])
   endif
endfunction
function! s:unit.damage(...) dict
   call s:message.print(printf('call s:unit.damage(%s)', self['type']))
   if a:0 == 0
      let self['life'] -= (dungeon#random() + 1)
   else
      let self['life'] -= a:1
   endif
   if self['life'] <= 0
      call s:message.print(printf('  unit was died, who type is %s', self['type']))
      call s:master.remove(self)
      call s:plain.replace(self['posx'], self['posy'], s:plain['icon'])
   endif
endfunction
function! s:unit.cure(...) dict
   call s:message.print(printf('call s:unit.cure(%s)', self['type']))
   if a:0 == 0
      let self['life'] += (dungeon#random() + 1)
   else
      let self['life'] += a:1
   endif
endfunction
" }}}
" let s:keeper {{{
let s:keeper = {}
let s:keeper['icon'] = '#'
let s:keeper['type'] = 'keeper'
let s:keeper['posx'] = 0
let s:keeper['posy'] = 0
let s:keeper['life'] = 0
let s:keeper['mana'] = 0
let s:keeper['hate'] = 0
function! s:keeper.action() dict
   let command = nr2char(getchar())
   if command == 'q' || command == ''
      return v:false
   endif
   call self['action_' . command]()
   return v:true
endfunction
function! s:keeper.action_h() dict
   call call(s:unit['move_left'], [], self)
endfunction
function! s:keeper.action_j() dict
   call call(s:unit['move_down'], [], self)
endfunction
function! s:keeper.action_k() dict
   call call(s:unit['move_up'], [], self)
endfunction
function! s:keeper.action_l() dict
   call call(s:unit['move_right'], [], self)
endfunction
function! s:keeper.action_s() dict
   let name = input('monster type: ', '', 'customlist,dungeon#monsterlist')
   if has_key(s:monsters['dict'], name)
      let monster = deepcopy(s:monsters['dict'][name])
      if self['mana'] >= monster['mana']
         let self['mana'] -= monster['mana']
         let [monster['posx'], monster['posy']] = s:plain.getplain()
         call dungeon#create(monster)
      endif
   endif
endfunction
function! s:keeper['action_w']() dict
   let self['mana'] += 1
endfunction
function! s:keeper.action_d() dict
   " TODO: test
   call dungeon#debug()
   sleep 2000ms
endfunction
function! s:keeper.action_m() dict
   call s:message.history()
   sleep 2000ms
endfunction
" }}}
" let s:gate {{{
let s:gate = {}
let s:gate['icon'] = '%'
let s:gate['type'] = 'gate'
let s:gate['posx'] = 0
let s:gate['posy'] = 0
let s:gate['life'] = 0
let s:gate['mana'] = 0
let s:gate['hate'] = 0
function! s:gate.action() dict
   call s:message.print('gate.action()')
   let self['mana'] += 1
   if self['mana'] > 7
      if dungeon#random(3) == 0
         " summon
         let idx = dungeon#random(len(s:braves['list']))
         let name = s:braves['list'][idx]
         let brave = deepcopy(s:braves['dict'][name])
         if self['mana'] >= brave['mana']
            let self['mana'] -= brave['mana']
            let [brave['posx'], brave['posy']] = s:plain.getplain()
            call dungeon#create(brave)
         endif
      endif
   endif
endfunction
" }}}

""" action
" let s:action {{{
let s:action = {}
function! s:action.get_crossess() dict
   let _cross = []
   call add( _cross, dungeon#getobj(self['posx']    , self['posy'] - 1) )
   call add( _cross, dungeon#getobj(self['posx']    , self['posy'] + 1) )
   call add( _cross, dungeon#getobj(self['posx'] - 1, self['posy']    ) )
   call add( _cross, dungeon#getobj(self['posx'] + 1, self['posy']    ) )
   return _cross
endfunction
function! s:action.attack_random() dict
   " summary: Ëøë„Åè„ÅÆÊïµ„ÇíÁÑ°‰ΩúÁÇ∫„Å´ÊîªÊíÉ
   let cross = call(s:action.get_crossess, [], self)
   if self['type'] == 'brave'
      call filter(cross, 'v:val["type"] == "keeper" || v:val["type"] == "monster"')
   else
      call filter(cross, 'v:val["type"] == "brave" || v:val["type"] == "gate"')
   endif
   if len(cross) != 0
      let enemy = cross[dungeon#random(len(cross))]
      let index = s:master.getindex(enemy)
      call call(s:unit['damage'], [], s:master['list'][index])
      return v:true
   endif
   return v:false
endfunction
function! s:action.attack_highhate() dict
   " summary: hate„ÇíÊúÄ„ÇÇÁ®º„ÅÑ„Åß„ÅÑ„ÇãÊïµ„ÇíÊîªÊíÉ
   let cross = call(s:action.get_crossess, [], self)
   if self['type'] == 'brave'
      call filter(cross, 'v:val["type"] == "keeper" || v:val["type"] == "monster"')
   else
      call filter(cross, 'v:val["type"] == "brave" || v:val["type"] == "gate"')
   endif
   if len(cross) != 0
      let _hate = max(map(deepcopy(cross), 'v:val["hate"]' ))
      call filter(cross, printf('v:val["hate"] == %s', _hate))
      let enemy = cross[dungeon#random(len(cross))]
      let index = s:master.getindex(enemy)
      call call(s:unit['damage'], [], s:master['list'][index])
      return v:true
   endif
   return v:false
endfunction
function! s:action.move_access(unit) dict
   let actions = []
   let x = a:unit['posx'] - self['posx']
   let y = a:unit['posy'] - self['posy']
   if x > 0
      call add(actions, 'move_right')
   elseif x < 0
      call add(actions, 'move_left')
   endif
   if y > 0
      call add(actions, 'move_down')
   elseif y < 0
      call add(actions, 'move_up')
   endif
   let action = actions[dungeon#random(len(actions))]
   call call(s:unit[action], [], self)
endfunction
function! s:action.move_enemy() dict
   let enemy = deepcopy(s:master['list'])
   if self['type'] == 'brave'
      call filter(enemy, 'v:val["type"] == "keeper" || v:val["type"] == "monster"')
   else
      call filter(enemy, 'v:val["type"] == "brave" || v:val["type"] == "gate"')
   endif
   let _distance = min(map(deepcopy(enemy), printf('abs(v:val["posx"] - %s) + abs(v:val["posy"] - %s)', self['posx'], self['posy'])))
   if _distance < 2
      return
   endif
   call filter(enemy, printf('abs(v:val["posx"] - %s) + abs(v:val["posy"] - %s) == %s', self['posx'], self['posy'], _distance))
   let enemy = enemy[dungeon#random(len(enemy))]
   call call(s:action.move_access, [enemy], self)
endfunction
function! s:action.move_friend() dict
   let friend = deepcopy(s:master['list'])
   if self['type'] == 'brave'
      call filter(friend, 'v:val["type"] == "brave" || v:val["type"] == "gate"')
   else
      call filter(friend, 'v:val["type"] == "keeper" || v:val["type"] == "monster"')
   endif
   let _distance = min(map(deepcopy(friend), printf('abs(v:val["posx"] - %s) + abs(v:val["posy"] - %s)', self['posx'], self['posy'])))
   if _distance < 2
      return
   endif
   call filter(friend, printf('abs(v:val["posx"] - %s) + abs(v:val["posy"] - %s) == %s', self['posx'], self['posy'], _distance))
   let friend = friend[dungeon#random(len(friend))]
   call call(s:action.move_access, [friend], self)
endfunction
function! s:action.confusion() dict
   " summary: ÂõõÊñπ„Çírandom„Å´ÈÅ∏„Å≥„ÄÅplain„Å™„ÇâÁßªÂãï„ÄÅÂ£Å„ÅØ‰Ωï„ÇÇ„Åõ„Åö„ÄÅ‰ªñ„Å™„ÇâÊîªÊíÉ
   let cross = call(s:action.get_crossess, [], self)
   let target = cross[dungeon#random(len(cross))]
   if target['type'] != 'plain'
      " ÁßªÂãï
      call call(s:unit['move'], [target['posx'], target['posy']], self)
   elseif target['type'] != 'wall'
      " Â£Å„Å™„Çâ‰Ωï„ÇÇ„Åó„Å™„ÅÑ
   else
      " ÊÆ¥„Çã
      let index = s:master.getindex(target)
      call call(s:unit['damage'], [], s:master['list'][index])
   endif
endfunction
function! s:action.berserker() dict
   " summary: Âë®„Çä„Å´‰Ωï„ÇÇ„Å™„Åë„Çå„Å∞ÁßªÂãï„ÄÅ
   "          „ÅÇ„Çå„Å∞„ÄÅ„Å®„Å´„Åã„ÅèÊÆ¥„Çã
   let cross = call(s:action.get_crossess, [], self)
   call filter(cross, 'v:val["type"] != "plain"')
   if len(cross) != 0
      let target = cross[dungeon#random(len(cross))]
      if target['type'] == 'wall'
         " Â£Å„ÇíÊÆ¥„Çã„ÄÅËá™ÊªÖ„ÉÄ„É°„Éº„Ç∏Áô∫Áîü
         call call(s:unit['damage'], [], self)
      else
         " Áõ∏Êâã„ÇíÊÆ¥„Çã
         let index = s:master.getindex(target)
         call call(s:unit['damage'], [], s:master['list'][index])
      endif
   else
      " ÁßªÂãï
      call call(s:unit['move_random'], [], self)
   endif
endfunction
" }}}
" function s:action.{monster}() {{{
function! s:action.bat() dict
   " priority: attack
   " move: random
   " attack: Ëøë„Åè„ÅÆÊïµ„ÇíÁÑ°‰ΩúÁÇ∫„Å´ÊîªÊíÉ
   " skill: Âê∏Ë°Ä(cure) „Åæ„Çå„Å´Áô∫Âãï
   let cross = call(s:action.get_crossess, [], self)
   call filter(cross, 'v:val["type"] == "brave" || v:val["type"] == "gate"')
   if len(cross) != 0
      call s:message.print('bat attack')
      let enemy = cross[dungeon#random(len(cross))]
      let index = s:master.getindex(enemy)
      call call(s:unit['damage'], [], s:master['list'][index])
      if dungeon#random(7) == 0
         call call(s:unit['cure'], [], self)
      endif
      return
   endif
   call call(s:unit['move_random'], [], self)
endfunction
function! s:action.slime() dict
   " priority: attack
   " move: ÊôÇ„ÄÖrandom„Å´Âãï„Åè
   " attack: Ëøë„Åè„ÅÆÊïµ„ÇíÁÑ°‰ΩúÁÇ∫„Å´ÊîªÊíÉ
   " skill: none
   call s:message.print('slime turn')
endfunction
function! s:action.goblin() dict
   " priority: ‰ª≤Èñì„ÅåËøë„Åè„Å´„ÅÑ„Çå„Å∞ÊîªÊíÉ„ÄÅ„ÅÑ„Å™„Åë„Çå„Å∞‰ª≤Èñì„ÅÆËøë„Åè„Å´ÁßªÂãï
   " move: ‰ª≤Èñì„ÅÆËøë„Åè„Å´
   " attack: hate„ÅåÈ´ò„ÅÑÊïµ
   " skill: none
   call s:message.print('goblin turn')
endfunction
function! s:action.gengar() dict
   " priority: none
   " move: Âü∫Êú¨Âãï„Åã„Å™„ÅÑ„ÄÅËøë„Åè„Å´Ë™∞„Åã„Åå„ÅÑ„Çã„Å®„ÄÅ„ÅÑ„Å™„ÅÑÊñπÂêë„Å´ÁßªÂãï
   " attack: near-enemy
   " skill: Ëá™Ë∫´„ÅÆhateÂÄ§„Åå‰∏ã„Åå„Çã
   call s:message.print('gengar turn')
endfunction
function! s:action.skeleton() dict
   " priority: attack
   " move: near-enemy
   " attack: near-enemy
   " skill: Êïµ„ÇíÂÄí„Åó„Åü„Å®„Åç„ÄÅËá™Ë∫´„ÅÆmana„ÇíÊ∂àË≤ª„ÅóÊ≠ª‰Ωì„Çískeleton„Å´„Åô„Çã
   call s:message.print('skeleton turn')
endfunction
function! s:action.element() dict
   " priority: escape, cure me, cure friend
   " move: Âü∫Êú¨Âãï„Åã„Å™„ÅÑ„ÄÅËøë„Åè„Å´Êïµ„Åå„ÅÑ„Çã„Å®ÈÄÉ„Åí„Çã
   " attack: ÊîªÊíÉ„Åó„Å™„ÅÑ„ÄÅËá™Ë∫´„Åã‰ª≤Èñì„Çícure
   " skill: ÂõûÂæ©(mana1„ÇíÊ∂àË≤ª) „Åæ„Çå„Å´mana„ÇíÂõûÂæ©
   call s:message.print('element turn')
endfunction
function! s:action.armor() dict
   " priority: attack
   " move: near-enemy
   " attack: high hate
   " skill: none
   call s:message.print('armor turn')
endfunction
function! s:action.harpy() dict
   " priority: attack
   " move: Ëøë„Åè„ÅÆ‰ª≤Èñì„ÅÆ„Å®„Åì„Çç„Å´ÁßªÂãï
   " attack: high hate
   " skill: È≠Ö‰∫Ü
   call s:message.print('harpy turn')
endfunction
function! s:action.fiary() dict
   " priority: escape
   " move: ÊôÇ„ÄÖrandom„Å´Âãï„Åè
   " attack: ÊîªÊíÉ„Åô„Çã„Åã„ÄÅÊäÄËÉΩ„Çí„Å§„Åã„ÅÜ
   " skill: ÂØæË±°„ÇíÁä∂ÊÖãÁï∞Â∏∏(Ê∑∑‰π±)„Å´„Åô„Çã changeling
   call s:message.print('fiary turn')
endfunction
function! s:action.witch() dict
   " priority: mana„ÅÆÁä∂ÊÖã„Å´„Çà„Çã
   " move: Ëøë„Åè„Å´Êïµ„Åå„ÅÑ„Çã(manaÊúâÊîªÊíÉ„ÄÅmanaÁÑ°ÈÄÉ„Åí„Çã)
   "       Êïµ„Åå„ÅÑ„Å™„ÅÑ(manaÊúârandomÁßªÂãï„ÄÅmanaÁÑ°ÁßªÂãï„Åõ„ÅömanaÂõûÂæ©)
   " attack: mana„ÇíÊ∂àË≤ª„ÅóÊäÄËÉΩ„Çí‰Ωø„ÅÜ
   " skill: ÂØæË±°„ÇíÁä∂ÊÖãÁï∞Â∏∏(ÁãÇÂåñ)„Å´„Åô„Çã
   call s:message.print('witch turn')
endfunction
" }}}
" function s:action.{brave}() {{{
function! s:action.fighter() dict
   " priority: attack
   " move: near-enemy
   " attack: Ëøë„Åè„ÅÆÊïµ„ÇíÁÑ°‰ΩúÁÇ∫„Å´ÊîªÊíÉ
   " skill: none
   call s:message.print('fighter turn')
   if !call(s:action.attack_random, [], self)
      call call(s:action.move_enemy, [], self)
   endif
endfunction
function! s:action.sword() dict
   call s:message.print('sword turn')
   if !call(s:action.attack_random, [], self)
      call call(s:action.move_enemy, [], self)
   endif
endfunction
function! s:action.bishop() dict
   call s:message.print('bishop turn')
   if !call(s:action.attack_random, [], self)
      call call(s:action.move_enemy, [], self)
   endif
endfunction
function! s:action.kid() dict
   call s:message.print('kid turn')
   if !call(s:action.attack_random, [], self)
      call call(s:action.move_enemy, [], self)
   endif
endfunction
function! s:action.lancer() dict
   call s:message.print('lancer turn')
   if !call(s:action.attack_random, [], self)
      call call(s:action.move_enemy, [], self)
   endif
endfunction
function! s:action.tamer() dict
   call s:message.print('tamer turn')
   if !call(s:action.attack_random, [], self)
      call call(s:action.move_enemy, [], self)
   endif
endfunction
function! s:action.rook() dict
   call s:message.print('rook turn')
   if !call(s:action.attack_random, [], self)
      call call(s:action.move_enemy, [], self)
   endif
endfunction
function! s:action.assassin() dict
   call s:message.print('assassin turn')
   if !call(s:action.attack_random, [], self)
      call call(s:action.move_enemy, [], self)
   endif
endfunction
function! s:action.wizard() dict
   call s:message.print('wizard turn')
   if !call(s:action.attack_random, [], self)
      call call(s:action.move_enemy, [], self)
   endif
endfunction
function! s:action.magician() dict
   call s:message.print('magician turn')
   if !call(s:action.attack_random, [], self)
      call call(s:action.move_enemy, [], self)
   endif
endfunction
function! s:action.criminal() dict
   call s:message.print('criminal turn')
   if !call(s:action.attack_random, [], self)
      call call(s:action.move_enemy, [], self)
   endif
endfunction
" }}}

""" monsters & braves
" let s:monsters {{{
let s:monsters = {}
let s:monsters['list'] = [ 'bat', 'slime', 'goblin', 'gengar', 'skeleton', 'element', 'armor', 'harpy', 'fiary', 'witch' ]
let s:monsters['dict'] = {
         \ 'bat':      { 'icon': '^', 'type': 'monster', 'life': 2, 'mana': 2, 'hate': 1, 'action': s:action.bat },
         \ 'slime':    { 'icon': '3', 'type': 'monster', 'life': 2, 'mana': 3, 'hate': 0, 'action': s:action.slime },
         \ 'goblin':   { 'icon': '@', 'type': 'monster', 'life': 3, 'mana': 3, 'hate': 2, 'action': s:action.goblin },
         \ 'gengar':   { 'icon': '&', 'type': 'monster', 'life': 4, 'mana': 7, 'hate': 0, 'action': s:action.gengar },
         \ 'skeleton': { 'icon': '!', 'type': 'monster', 'life': 3, 'mana': 3, 'hate': 0, 'action': s:action.skeleton },
         \ 'element':  { 'icon': '8', 'type': 'monster', 'life': 2, 'mana': 5, 'hate': 0, 'action': s:action.element },
         \ 'armor':    { 'icon': '=', 'type': 'monster', 'life': 8, 'mana': 7, 'hate': 0, 'action': s:action.armor },
         \ 'harpy':    { 'icon': '~', 'type': 'monster', 'life': 4, 'mana': 6, 'hate': 0, 'action': s:action.harpy },
         \ 'fiary':    { 'icon': '*', 'type': 'monster', 'life': 3, 'mana': 6, 'hate': 0, 'action': s:action.fiary },
         \ 'witch':    { 'icon': '$', 'type': 'monster', 'life': 4, 'mana': 7, 'hate': 0, 'action': s:action.witch }
         \ }
" }}}
" let s:braves {{{
let s:braves = {}
let s:braves['list'] = [ 'fighter', 'sword', 'bishop', 'kid', 'lancer', 'tamer', 'rook', 'assassin', 'wizard', 'magician', 'criminal' ]
let s:braves['dict'] = {
         \ 'fighter':  { 'icon': 'F', 'type': 'brave', 'life': 4, 'mana': 5, 'hate': 0, 'action': s:action.fighter },
         \ 'sword':    { 'icon': 'S', 'type': 'brave', 'life': 5, 'mana': 5, 'hate': 0, 'action': s:action.sword },
         \ 'bishop':   { 'icon': 'B', 'type': 'brave', 'life': 3, 'mana': 5, 'hate': 0, 'action': s:action.bishop },
         \ 'kid':      { 'icon': 'K', 'type': 'brave', 'life': 1, 'mana': 4, 'hate': 0, 'action': s:action.kid },
         \ 'lancer':   { 'icon': 'L', 'type': 'brave', 'life': 6, 'mana': 8, 'hate': 0, 'action': s:action.lancer },
         \ 'tamer':    { 'icon': 'T', 'type': 'brave', 'life': 3, 'mana': 6, 'hate': 1, 'action': s:action.tamer },
         \ 'rook':     { 'icon': 'R', 'type': 'brave', 'life': 3, 'mana': 4, 'hate': 0, 'action': s:action.rook },
         \ 'assassin': { 'icon': 'A', 'type': 'brave', 'life': 3, 'mana': 7, 'hate': 2, 'action': s:action.assassin },
         \ 'wizard':   { 'icon': 'W', 'type': 'brave', 'life': 3, 'mana': 9, 'hate': 0, 'action': s:action.wizard },
         \ 'magician': { 'icon': 'M', 'type': 'brave', 'life': 3, 'mana': 8, 'hate': 1, 'action': s:action.magician },
         \ 'criminal': { 'icon': 'C', 'type': 'brave', 'life': 5, 'mana': 5, 'hate': 6, 'action': s:action.criminal }
         \}
" }}}
" function dungeon#monsterlist(...) {{{
function! dungeon#monsterlist(...)
   return s:monsters['list']
endfunction
" }}}
" function dungeon#bravelist(...) {{{
function! dungeon#bravelist(...)
   return s:braves['list']
endfunction
" }}}

""" functions common
" function dungeon#clear() {{{
function! dungeon#clear()
   let s:dungeon['bufnr'] = 0
   let s:dungeon['posx'] = 0
   let s:dungeon['posy'] = 0
   let s:dungeon['vertical'] = 0
   let s:dungeon['horizontal'] = 0
   let s:master['list'] = []
endfunction
" }}}
" function dungeon#create(obj) {{{
function! dungeon#create(obj)
   call s:message.print(printf('call dungeon#create(%s)', a:obj['type']))
   call s:plain.replace(a:obj['posx'], a:obj['posy'], a:obj['icon'])
   call s:master.add(a:obj)
endfunction
" }}}
" function dungeon#random(...) {{{
function! dungeon#random(...)
   if a:0 == 0
      let l:rand = 2
   else
      let l:rand = a:1
   endif
   let log = -1 * (float2nr(log10(l:rand)) + 1)
   let ret = reltimestr(reltime())[log:]
   return ret % l:rand
endfunction
" }}}
" function dungeon#getobj(x, y) {{{
function! dungeon#getobj(x, y)
   let obj = s:master.exists(a:x, a:y)
   if type(obj) == v:t_dict
      return obj
   endif
   let obj = {}
   let obj['posx'] = a:x
   let obj['posy'] = a:y
   if s:plain.isplain(a:x, a:y)
      let obj['icon'] = '.'
      let obj['type'] = 'plain'
   else
      let obj['icon'] = ' '
      let obj['type'] = 'wall'
   endif
   return obj
endfunction
" }}}
" function dungeon#debug() {{{
function! dungeon#debug()
   vnew
   setlocal bufhidden=delete buftype=nofile
   call append(line('$'), '======= dungeon =======')
   for key in keys(s:dungeon)
      call append(line('$'), printf('dungeon.%s: %s', key, s:dungeon[key]))
   endfor
   call append(line('$'), '======= master-list =======')
   for unit in s:master['list']
      call append(line('$'), printf('%s:', unit['type']))
      for key in keys(unit)
         call append(line('$'), printf('  %s: %s', key, unit[key]))
      endfor
   endfor
endfunction
" }}}

""" functions initation
" function dungeon#open() {{{
function! dungeon#open()
   if s:dungeon['bufnr'] == 0
      tabnew [dungeon]
      setlocal filetype=dungeon
      setlocal nobackup noswapfile noundofile
      setlocal bufhidden=delete buftype=nofile
      setlocal nonumber norelativenumber
      setlocal nolist nospell nowrap
      setlocal nocursorline nocursorcolumn
      setlocal guioptions=
      autocmd! QuitPre <buffer> :call dungeon#clear()
      return
   endif
   if !bufexists(s:dungeon['bufnr'])
      echo 'error: buffer not found. -dungeon.vim'
      call dungeon#clear()
      return
   endif
   " MEMO: ÂàÜÂâ≤„Ç¶„Ç£„É≥„Éâ„Ç¶„Å´„ÅØÂØæÂøú„Åó„Å¶„Å™„ÅÑ
   let l:loop = v:true
   while l:loop
      let l:bufnr = bufnr('%')
      if s:dungeon['bufnr'] == l:bufnr
         let l:loop = v:false
      else
         normal! gt
      endif
   endwhile
endfunction
" }}}
" function dungeon#makefield() {{{
function! dungeon#makefield()
   let s:dungeon['posx'] = &columns / (2 + dungeon#random(6))
   let s:dungeon['posy'] = &lines   / (2 + dungeon#random(6))
   let s:dungeon['vertical']   = 5 + dungeon#random(3)
   let s:dungeon['horizontal'] = 5 + dungeon#random(3)
   silent normal! ggdG
   call append(line('$'), repeat([''], s:dungeon['posy'] - 1))
   call append(line('$'), repeat(
            \ [repeat(' ', s:dungeon['posx'] - 1) . repeat('.', s:dungeon['horizontal'])],
            \ s:dungeon['vertical'] ))
   silent normal! ggdd
endfunction
" }}}
" function dungeon#keeperstand() {{{
function! dungeon#keeperstand()
   let keeper = deepcopy(s:keeper)
   let [keeper['posx'], keeper['posy']] = s:plain.getplain()
   let keeper['life'] = 10
   let keeper['mana'] = 10
   call dungeon#create(keeper)
endfunction
" }}}
" function dungeon#makegate() {{{
function! dungeon#makegate()
   let gate = deepcopy(s:gate)
   let [gate['posx'], gate['posy']] = s:plain.getplain()
   let gate['life'] = 25
   let gate['mana'] = 10
   call dungeon#create(gate)
endfunction
" }}}


function! dungeon#make()
   call dungeon#open()
   if s:dungeon['bufnr'] == 0
      let s:dungeon['bufnr'] = bufnr('%')
      call dungeon#makefield()
      call dungeon#keeperstand()
      call dungeon#makegate()
   endif
   redraw
   let loop = v:true
   while loop
      let loop = s:master['action']()
      call s:master['next']()
      redraw
      sleep 300ms
   endwhile
   quit
endfunction

" TEST: assert
let g:dcross = [ { 'num': 1, 'hate': 2 }, { 'num': 2, 'hate': 3 }, { 'num': 3, 'hate': 2 }, { 'num': 4, 'hate': 1 } ]

" vim: set ts=3 sts=3 sw=3 et :
